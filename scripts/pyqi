#!/usr/bin/env python

#-----------------------------------------------------------------------------
# Copyright (c) 2013, The BiPy Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#-----------------------------------------------------------------------------

__author__ = "Daniel McDonald"
__copyright__ = "Copyright 2013, The pyqi Project"
__credits__ = ["Greg Caporaso", "Daniel McDonald", "Doug Wendel",
               "Jai Ram Rideout"]
__license__ = "BSD"
__version__ = "0.1.0-dev"
__maintainer__ = "Daniel McDonald"
__email__ = "mcdonadt@colorado.edu"

import importlib
from sys import argv, exit, stderr
from pyqi.core.interface import get_command_names, get_config_base_name
from pyqi.core.interfaces.optparse import optparse_main, optparse_factory
from os.path import basename
from string import ljust 

### we actually have some flexibility here to make the driver interface agnostic as well

# drop any path fluff
argv[0] = basename(argv[0])
config_base_name = get_config_base_name(argv[0])
command_names = get_command_names(config_base_name)

def usage(opts):
    """Modeled after git..."""
    # limit to a reasonable number of characters
    term_width = 80
    indent = 3

    print "usage: %s <command> [<args>]" % argv[0]
    print
    print "The currently available commands are:"

    for c in command_names:
        cmd_cfg = get_cmd_cfg(c, opts)
        desc = cmd_cfg.CommandConstructor.BriefDescription
        cmds_and_desc.append((c, desc))

    # determine widths
    max_cmd = max(map(lambda x: len(x[0]), cmds_and_desc))
    desc_limit = term_width - (indent + max_cmd + indent)
    cmd_end = indent + max_cmd + indent

    print "usage: %s <command> [<args>]" % argv[0]
    print
    print "The currently available commands are:"
    
    # format:
    # indent command indent description
    for c,desc in cmds_and_desc:
        cmd_formatted = ljust(''.join([' ' * indent, c]), cmd_end)
        print ''.join([cmd_formatted, desc[:desc_limit]])
    
    print
    print "See '%s help <command>' for more information on a specific command." % argv[0]
    exit(0)

def unknown_command(cmd):
    """Handle an unknown command"""
    stderr.write("Unknown command: %s\n" % cmd)
    exit(1)

def cmd_exists(cmd):
    """Check if a ``Command`` configuration exists"""
    return cmd in command_names

def get_cmd_cfg(cmd, opts):
    """Get the configuration for a ``Command``"""
    try:
        cmd_cfg = importlib.import_module('.'.join([config_base_name, cmd]))
    except ImportError, e:
        stderr.write("Unable to import the command configuration for %s.\n" % cmd)
        if opts['--verbose']:
            stderr.write(str(e))
            stderr.write('\n')
        exit(1)
    return cmd_cfg

def get_cmd_obj(cmd, opts):
    """Get a ``Command`` object"""
    cmd_cfg = get_cmd_cfg(cmd, opts)
    return optparse_factory(cmd_cfg.CommandConstructor, cmd_cfg.usage_examples, 
                            cmd_cfg.inputs, cmd_cfg.outputs)

def help_(cmd, opts):
    """Dump the help for a ``Command``"""
    cmd_obj = get_cmd_obj(cmd, opts)
    optparse_main(cmd_obj, ['help','-h'])

if __name__ == '__main__':
    opts = {'--verbose':False}

    if len(argv) == 1:
        usage(opts)
    else:
        # check if argv[1] is one of our special options
        if argv[1] in opts:
            # and then handle it ungracefully
            if len(argv) == 2:
                opts['--verbose'] = True
                usage(opts)
            opts[argv[1]] = True
            argv.pop(1)
        cmd = argv[1]

    # if the command appears to be some cry for help
    if cmd in ['help','HELP','-?','-h']:
        if not len(argv) > 2:
            usage(opts)
        help_cmd = argv[2]

        # tears. 
        # .
        # this voodoo is to coerce optparse/argparse to dump the program name
        # at usage and examples correctly.
        argv[0] = ' '.join([argv[0], argv[2]])
        if cmd_exists(help_cmd):
            help_(help_cmd, opts)
        else:
            unknown_command(help_cmd)
    else:
        # see the note about crying about tears.
        argv[0] = ' '.join([argv[0], argv[1]])

    if not cmd_exists(cmd):
        unknown_command(cmd)

    cmd_obj = get_cmd_obj(cmd, opts)
    
    # and execute FTW
    optparse_main(cmd_obj, argv[1:])
